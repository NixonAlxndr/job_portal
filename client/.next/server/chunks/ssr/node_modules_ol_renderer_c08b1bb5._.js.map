{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/Map.js"],"sourcesContent":["/**\n * @module ol/renderer/Map\n */\nimport Disposable from '../Disposable.js';\nimport {wrapX} from '../coordinate.js';\nimport {getWidth} from '../extent.js';\nimport {TRUE} from '../functions.js';\nimport {inView} from '../layer/Layer.js';\nimport {shared as iconImageCache} from '../style/IconImageCache.js';\nimport {compose as composeTransform, makeInverse} from '../transform.js';\nimport {abstract} from '../util.js';\n\n/**\n * @template T\n * @typedef HitMatch\n * @property {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @property {import(\"../layer/Layer.js\").default} layer Layer.\n * @property {import(\"../geom/SimpleGeometry.js\").default} geometry Geometry.\n * @property {number} distanceSq Squared distance.\n * @property {import(\"./vector.js\").FeatureCallback<T>} callback Callback.\n */\n\n/**\n * @abstract\n */\nclass MapRenderer extends Disposable {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super();\n\n    /**\n     * @private\n     * @type {import(\"../Map.js\").default}\n     */\n    this.map_ = map;\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  dispatchRenderEvent(type, frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @protected\n   */\n  calculateMatrices2D(frameState) {\n    const viewState = frameState.viewState;\n    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;\n    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;\n\n    composeTransform(\n      coordinateToPixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / viewState.resolution,\n      -1 / viewState.resolution,\n      -viewState.rotation,\n      -viewState.center[0],\n      -viewState.center[1],\n    );\n\n    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {S} thisArg Value to use as `this` when executing `callback`.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.\n   * @return {T|undefined} Callback result.\n   * @template S,T,U\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    callback,\n    thisArg,\n    layerFilter,\n    thisArg2,\n  ) {\n    let result;\n    const viewState = frameState.viewState;\n\n    /**\n     * @param {boolean} managed Managed layer.\n     * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../layer/Layer.js\").default} layer Layer.\n     * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n     * @return {T|undefined} Callback result.\n     */\n    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {\n      return callback.call(thisArg, feature, managed ? layer : null, geometry);\n    }\n\n    const projection = viewState.projection;\n\n    const translatedCoordinate = wrapX(coordinate.slice(), projection);\n    const offsets = [[0, 0]];\n    if (projection.canWrapX() && checkWrapped) {\n      const projectionExtent = projection.getExtent();\n      const worldWidth = getWidth(projectionExtent);\n      offsets.push([-worldWidth, 0], [worldWidth, 0]);\n    }\n\n    const layerStates = frameState.layerStatesArray;\n    const numLayers = layerStates.length;\n\n    const matches = /** @type {Array<HitMatch<T>>} */ ([]);\n    const tmpCoord = [];\n    for (let i = 0; i < offsets.length; i++) {\n      for (let j = numLayers - 1; j >= 0; --j) {\n        const layerState = layerStates[j];\n        const layer = layerState.layer;\n        if (\n          layer.hasRenderer() &&\n          inView(layerState, viewState) &&\n          layerFilter.call(thisArg2, layer)\n        ) {\n          const layerRenderer = layer.getRenderer();\n          const source = layer.getSource();\n          if (layerRenderer && source) {\n            const coordinates = source.getWrapX()\n              ? translatedCoordinate\n              : coordinate;\n            const callback = forEachFeatureAtCoordinate.bind(\n              null,\n              layerState.managed,\n            );\n            tmpCoord[0] = coordinates[0] + offsets[i][0];\n            tmpCoord[1] = coordinates[1] + offsets[i][1];\n            result = layerRenderer.forEachFeatureAtCoordinate(\n              tmpCoord,\n              frameState,\n              hitTolerance,\n              callback,\n              matches,\n            );\n          }\n          if (result) {\n            return result;\n          }\n        }\n      }\n    }\n    if (matches.length === 0) {\n      return undefined;\n    }\n    const order = 1 / matches.length;\n    matches.forEach((m, i) => (m.distanceSq += i * order));\n    matches.sort((a, b) => a.distanceSq - b.distanceSq);\n    matches.some((m) => {\n      return (result = m.callback(m.feature, m.layer, m.geometry));\n    });\n    return result;\n  }\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState FrameState.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {boolean} checkWrapped Check for wrapped geometries.\n   * @param {function(this: U, import(\"../layer/Layer.js\").default): boolean} layerFilter Layer filter\n   *     function, only layers which are visible and for which this function\n   *     returns `true` will be tested for features.  By default, all visible\n   *     layers will be tested.\n   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.\n   * @return {boolean} Is there a feature at the given coordinate?\n   * @template U\n   */\n  hasFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    checkWrapped,\n    layerFilter,\n    thisArg,\n  ) {\n    const hasFeature = this.forEachFeatureAtCoordinate(\n      coordinate,\n      frameState,\n      hitTolerance,\n      checkWrapped,\n      TRUE,\n      this,\n      layerFilter,\n      thisArg,\n    );\n\n    return hasFeature !== undefined;\n  }\n\n  /**\n   * @return {import(\"../Map.js\").default} Map.\n   */\n  getMap() {\n    return this.map_;\n  }\n\n  /**\n   * Render.\n   * @abstract\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderFrame(frameState) {\n    abstract();\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  scheduleExpireIconCache(frameState) {\n    if (iconImageCache.canExpireCache()) {\n      frameState.postRenderFunctions.push(expireIconCache);\n    }\n  }\n}\n\n/**\n * @param {import(\"../Map.js\").default} map Map.\n * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n */\nfunction expireIconCache(map, frameState) {\n  iconImageCache.expire();\n}\n\nexport default MapRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 191, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/Composite.js"],"sourcesContent":["/**\n * @module ol/renderer/Composite\n */\nimport ObjectEventType from '../ObjectEventType.js';\nimport {CLASS_UNSELECTABLE} from '../css.js';\nimport {replaceChildren} from '../dom.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport BaseVectorLayer from '../layer/BaseVector.js';\nimport {inView} from '../layer/Layer.js';\nimport RenderEvent from '../render/Event.js';\nimport RenderEventType from '../render/EventType.js';\nimport {checkedFonts} from '../render/canvas.js';\nimport MapRenderer from './Map.js';\n\n/**\n * @classdesc\n * Canvas map renderer.\n * @api\n */\nclass CompositeMapRenderer extends MapRenderer {\n  /**\n   * @param {import(\"../Map.js\").default} map Map.\n   */\n  constructor(map) {\n    super(map);\n\n    /**\n     * @private\n     * @type {import(\"../events.js\").EventsKey}\n     */\n    this.fontChangeListenerKey_ = listen(\n      checkedFonts,\n      ObjectEventType.PROPERTYCHANGE,\n      map.redrawText,\n      map,\n    );\n\n    /**\n     * @private\n     * @type {HTMLDivElement}\n     */\n    this.element_ = document.createElement('div');\n    const style = this.element_.style;\n    style.position = 'absolute';\n    style.width = '100%';\n    style.height = '100%';\n    style.zIndex = '0';\n\n    this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';\n\n    const container = map.getViewport();\n    container.insertBefore(this.element_, container.firstChild || null);\n\n    /**\n     * @private\n     * @type {Array<HTMLElement>}\n     */\n    this.children_ = [];\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedVisible_ = true;\n  }\n\n  /**\n   * @param {import(\"../render/EventType.js\").default} type Event type.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  dispatchRenderEvent(type, frameState) {\n    const map = this.getMap();\n    if (map.hasListener(type)) {\n      const event = new RenderEvent(type, undefined, frameState);\n      map.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @override\n   */\n  disposeInternal() {\n    unlistenByKey(this.fontChangeListenerKey_);\n    this.element_.remove();\n    super.disposeInternal();\n  }\n\n  /**\n   * Render.\n   * @param {?import(\"../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderFrame(frameState) {\n    if (!frameState) {\n      if (this.renderedVisible_) {\n        this.element_.style.display = 'none';\n        this.renderedVisible_ = false;\n      }\n      return;\n    }\n\n    this.calculateMatrices2D(frameState);\n    this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, frameState);\n\n    const layerStatesArray = frameState.layerStatesArray.sort(\n      (a, b) => a.zIndex - b.zIndex,\n    );\n    const declutter = layerStatesArray.some(\n      (layerState) =>\n        layerState.layer instanceof BaseVectorLayer &&\n        layerState.layer.getDeclutter(),\n    );\n    if (declutter) {\n      // Some layers need decluttering, turn on deferred rendering hint\n      frameState.declutter = {};\n    }\n    const viewState = frameState.viewState;\n\n    this.children_.length = 0;\n\n    const renderedLayerStates = [];\n    let previousElement = null;\n    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {\n      const layerState = layerStatesArray[i];\n      frameState.layerIndex = i;\n\n      const layer = layerState.layer;\n      const sourceState = layer.getSourceState();\n      if (\n        !inView(layerState, viewState) ||\n        (sourceState != 'ready' && sourceState != 'undefined')\n      ) {\n        layer.unrender();\n        continue;\n      }\n\n      const element = layer.render(frameState, previousElement);\n      if (!element) {\n        continue;\n      }\n      if (element !== previousElement) {\n        this.children_.push(element);\n        previousElement = element;\n      }\n\n      renderedLayerStates.push(layerState);\n    }\n\n    this.declutter(frameState, renderedLayerStates);\n\n    replaceChildren(this.element_, this.children_);\n\n    this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, frameState);\n\n    if (!this.renderedVisible_) {\n      this.element_.style.display = '';\n      this.renderedVisible_ = true;\n    }\n\n    this.scheduleExpireIconCache(frameState);\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {Array<import('../layer/Layer.js').State>} layerStates Layers.\n   */\n  declutter(frameState, layerStates) {\n    if (!frameState.declutter) {\n      return;\n    }\n    for (let i = layerStates.length - 1; i >= 0; --i) {\n      const layerState = layerStates[i];\n      const layer = layerState.layer;\n      if (layer.getDeclutter()) {\n        layer.renderDeclutter(frameState, layerState);\n      }\n    }\n    layerStates.forEach((layerState) =>\n      layerState.layer.renderDeferred(frameState),\n    );\n  }\n}\n\nexport default CompositeMapRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/Layer\n */\nimport ImageState from '../ImageState.js';\nimport Observable from '../Observable.js';\nimport EventType from '../events/EventType.js';\nimport {abstract} from '../util.js';\n\nconst maxStaleKeys = 5;\n\n/**\n * @template {import(\"../layer/Layer.js\").default} LayerType\n */\nclass LayerRenderer extends Observable {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super();\n\n    /**\n     * The renderer is initialized and ready to render.\n     * @type {boolean}\n     */\n    this.ready = true;\n\n    /** @private */\n    this.boundHandleImageChange_ = this.handleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {LayerType}\n     */\n    this.layer_ = layer;\n\n    /**\n     * @type {Array<string>}\n     * @private\n     */\n    this.staleKeys_ = new Array();\n\n    /**\n     * @type {number}\n     * @protected\n     */\n    this.maxStaleKeys = maxStaleKeys;\n  }\n\n  /**\n   * @return {Array<string>} Get the list of stale keys.\n   */\n  getStaleKeys() {\n    return this.staleKeys_;\n  }\n\n  /**\n   * @param {string} key The new stale key.\n   */\n  prependStaleKey(key) {\n    this.staleKeys_.unshift(key);\n    if (this.staleKeys_.length > this.maxStaleKeys) {\n      this.staleKeys_.length = this.maxStaleKeys;\n    }\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../Feature\").FeatureLike>>} Promise that resolves with\n   * an array of features.\n   */\n  getFeatures(pixel) {\n    return abstract();\n  }\n\n  /**\n   * @param {import(\"../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.\n   */\n  getData(pixel) {\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrame(frameState) {\n    return abstract();\n  }\n\n  /**\n   * Render the layer.\n   * @abstract\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState, target) {\n    return abstract();\n  }\n\n  /**\n   * @abstract\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"./vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"./Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    return undefined;\n  }\n\n  /**\n   * @return {LayerType} Layer.\n   */\n  getLayer() {\n    return this.layer_;\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @abstract\n   */\n  handleFontsChanged() {}\n\n  /**\n   * Handle changes in image state.\n   * @param {import(\"../events/Event.js\").default} event Image change event.\n   * @private\n   */\n  handleImageChange_(event) {\n    const image = /** @type {import(\"../Image.js\").default} */ (event.target);\n    if (\n      image.getState() === ImageState.LOADED ||\n      image.getState() === ImageState.ERROR\n    ) {\n      this.renderIfReadyAndVisible();\n    }\n  }\n\n  /**\n   * Load the image if not already loaded, and register the image change\n   * listener if needed.\n   * @param {import(\"../Image.js\").default} image Image.\n   * @return {boolean} `true` if the image is already loaded, `false` otherwise.\n   * @protected\n   */\n  loadImage(image) {\n    let imageState = image.getState();\n    if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {\n      image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);\n    }\n    if (imageState == ImageState.IDLE) {\n      image.load();\n      imageState = image.getState();\n    }\n    return imageState == ImageState.LOADED;\n  }\n\n  /**\n   * @protected\n   */\n  renderIfReadyAndVisible() {\n    const layer = this.getLayer();\n    if (layer && layer.getVisible() && layer.getSourceState() === 'ready') {\n      layer.changed();\n    }\n  }\n\n  /**\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferred(frameState) {}\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.layer_;\n    super.disposeInternal();\n  }\n}\n\nexport default LayerRenderer;\n"],"names":[],"mappings":"AAAA;;CAEC;;;;AACD;AACA;AACA;AACA;;;;;AAEA,MAAM,eAAe;AAErB;;CAEC,GACD,MAAM,sBAAsB,2IAAU;IACpC;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,KAAK;QAEL;;;KAGC,GACD,IAAI,CAAC,KAAK,GAAG;QAEb,aAAa,GACb,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI;QAEhE;;;KAGC,GACD,IAAI,CAAC,MAAM,GAAG;QAEd;;;KAGC,GACD,IAAI,CAAC,UAAU,GAAG,IAAI;QAEtB;;;KAGC,GACD,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA;;GAEC,GACD,eAAe;QACb,OAAO,IAAI,CAAC,UAAU;IACxB;IAEA;;GAEC,GACD,gBAAgB,GAAG,EAAE;QACnB,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC;QACxB,IAAI,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY,EAAE;YAC9C,IAAI,CAAC,UAAU,CAAC,MAAM,GAAG,IAAI,CAAC,YAAY;QAC5C;IACF;IAEA;;;;;GAKC,GACD,YAAY,KAAK,EAAE;QACjB,OAAO,IAAA,sIAAQ;IACjB;IAEA;;;GAGC,GACD,QAAQ,KAAK,EAAE;QACb,OAAO;IACT;IAEA;;;;;GAKC,GACD,aAAa,UAAU,EAAE;QACvB,OAAO,IAAA,sIAAQ;IACjB;IAEA;;;;;;GAMC,GACD,YAAY,UAAU,EAAE,MAAM,EAAE;QAC9B,OAAO,IAAA,sIAAQ;IACjB;IAEA;;;;;;;;;GASC,GACD,2BACE,UAAU,EACV,UAAU,EACV,YAAY,EACZ,QAAQ,EACR,OAAO,EACP;QACA,OAAO;IACT;IAEA;;GAEC,GACD,WAAW;QACT,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA;;;GAGC,GACD,qBAAqB,CAAC;IAEtB;;;;GAIC,GACD,mBAAmB,KAAK,EAAE;QACxB,MAAM,QAAsD,MAAM,MAAM;QACxE,IACE,MAAM,QAAQ,OAAO,2IAAU,CAAC,MAAM,IACtC,MAAM,QAAQ,OAAO,2IAAU,CAAC,KAAK,EACrC;YACA,IAAI,CAAC,uBAAuB;QAC9B;IACF;IAEA;;;;;;GAMC,GACD,UAAU,KAAK,EAAE;QACf,IAAI,aAAa,MAAM,QAAQ;QAC/B,IAAI,cAAc,2IAAU,CAAC,MAAM,IAAI,cAAc,2IAAU,CAAC,KAAK,EAAE;YACrE,MAAM,gBAAgB,CAAC,oJAAS,CAAC,MAAM,EAAE,IAAI,CAAC,uBAAuB;QACvE;QACA,IAAI,cAAc,2IAAU,CAAC,IAAI,EAAE;YACjC,MAAM,IAAI;YACV,aAAa,MAAM,QAAQ;QAC7B;QACA,OAAO,cAAc,2IAAU,CAAC,MAAM;IACxC;IAEA;;GAEC,GACD,0BAA0B;QACxB,MAAM,QAAQ,IAAI,CAAC,QAAQ;QAC3B,IAAI,SAAS,MAAM,UAAU,MAAM,MAAM,cAAc,OAAO,SAAS;YACrE,MAAM,OAAO;QACf;IACF;IAEA;;GAEC,GACD,eAAe,UAAU,EAAE,CAAC;IAE5B;;;GAGC,GACD,kBAAkB;QAChB,OAAO,IAAI,CAAC,MAAM;QAClB,KAAK,CAAC;IACR;AACF;uCAEe","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 499, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/canvas/Layer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/Layer\n */\nimport {equals} from '../../array.js';\nimport {asArray} from '../../color.js';\nimport {createCanvasContext2D} from '../../dom.js';\nimport {\n  getBottomLeft,\n  getBottomRight,\n  getHeight,\n  getTopLeft,\n  getTopRight,\n  getWidth,\n} from '../../extent.js';\nimport RenderEvent from '../../render/Event.js';\nimport RenderEventType from '../../render/EventType.js';\nimport ZIndexContext from '../../render/canvas/ZIndexContext.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n  create as createTransform,\n  equivalent,\n  makeInverse,\n  toString as toTransformString,\n} from '../../transform.js';\nimport LayerRenderer from '../Layer.js';\n\n/**\n * @type {Array<HTMLCanvasElement>}\n */\nexport const canvasPool = [];\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\n\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true,\n  });\n}\n\n/**\n * @abstract\n * @template {import(\"../../layer/Layer.js\").default} LayerType\n * @extends {LayerRenderer<LayerType>}\n */\nclass CanvasLayerRenderer extends LayerRenderer {\n  /**\n   * @param {LayerType} layer Layer.\n   */\n  constructor(layer) {\n    super(layer);\n\n    /**\n     * @protected\n     * @type {HTMLElement}\n     */\n    this.container = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedResolution;\n\n    /**\n     * A temporary transform.  The values in this transform should only be used in a\n     * function that sets the values.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.tempTransform = createTransform();\n\n    /**\n     * The transform for rendered pixels to viewport CSS pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.pixelTransform = createTransform();\n\n    /**\n     * The transform for viewport CSS pixels to rendered pixels.  This transform must\n     * be set when rendering a frame and may be used by other functions after rendering.\n     * @protected\n     * @type {import(\"../../transform.js\").Transform}\n     */\n    this.inversePixelTransform = createTransform();\n\n    /**\n     * @type {CanvasRenderingContext2D}\n     */\n    this.context = null;\n\n    /**\n     * @private\n     * @type {ZIndexContext}\n     */\n    this.deferredContext_ = null;\n\n    /**\n     * @type {boolean}\n     */\n    this.containerReused = false;\n\n    /**\n     * @protected\n     * @type {import(\"../../Map.js\").FrameState|null}\n     */\n    this.frameState = null;\n  }\n\n  /**\n   * @param {import('../../DataTile.js').ImageLike} image Image.\n   * @param {number} col The column index.\n   * @param {number} row The row index.\n   * @return {Uint8ClampedArray|null} The image data.\n   */\n  getImageData(image, col, row) {\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n\n    let data;\n    try {\n      pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import('../../Map.js').FrameState} frameState Frame state.\n   * @return {string} Background color.\n   */\n  getBackground(frameState) {\n    const layer = this.getLayer();\n    let background = layer.getBackground();\n    if (typeof background === 'function') {\n      background = background(frameState.viewState.resolution);\n    }\n    return background || undefined;\n  }\n\n  /**\n   * Get a rendering container from an existing target, if compatible.\n   * @param {HTMLElement} target Potential render target.\n   * @param {string} transform CSS transform matrix.\n   * @param {string} [backgroundColor] Background color.\n   */\n  useContainer(target, transform, backgroundColor) {\n    const layerClassName = this.getLayer().getClassName();\n    let container, context;\n    if (\n      target &&\n      target.className === layerClassName &&\n      (!backgroundColor ||\n        (target &&\n          target.style.backgroundColor &&\n          equals(\n            asArray(target.style.backgroundColor),\n            asArray(backgroundColor),\n          )))\n    ) {\n      const canvas = target.firstElementChild;\n      if (canvas instanceof HTMLCanvasElement) {\n        context = canvas.getContext('2d');\n      }\n    }\n    if (context && equivalent(context.canvas.style.transform, transform)) {\n      // Container of the previous layer renderer can be used.\n      this.container = target;\n      this.context = context;\n      this.containerReused = true;\n    } else if (this.containerReused) {\n      // Previously reused container cannot be used any more.\n      this.container = null;\n      this.context = null;\n      this.containerReused = false;\n    } else if (this.container) {\n      this.container.style.backgroundColor = null;\n    }\n    if (!this.container) {\n      container = document.createElement('div');\n      container.className = layerClassName;\n      let style = container.style;\n      style.position = 'absolute';\n      style.width = '100%';\n      style.height = '100%';\n      context = createCanvasContext2D();\n      const canvas = context.canvas;\n      container.appendChild(canvas);\n      style = canvas.style;\n      style.position = 'absolute';\n      style.left = '0';\n      style.transformOrigin = 'top left';\n      this.container = container;\n      this.context = context;\n    }\n    if (\n      !this.containerReused &&\n      backgroundColor &&\n      !this.container.style.backgroundColor\n    ) {\n      this.container.style.backgroundColor = backgroundColor;\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent Clip extent.\n   * @protected\n   */\n  clipUnrotated(context, frameState, extent) {\n    const topLeft = getTopLeft(extent);\n    const topRight = getTopRight(extent);\n    const bottomRight = getBottomRight(extent);\n    const bottomLeft = getBottomLeft(extent);\n\n    applyTransform(frameState.coordinateToPixelTransform, topLeft);\n    applyTransform(frameState.coordinateToPixelTransform, topRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomRight);\n    applyTransform(frameState.coordinateToPixelTransform, bottomLeft);\n\n    const inverted = this.inversePixelTransform;\n    applyTransform(inverted, topLeft);\n    applyTransform(inverted, topRight);\n    applyTransform(inverted, bottomRight);\n    applyTransform(inverted, bottomLeft);\n\n    context.save();\n    context.beginPath();\n    context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));\n    context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));\n    context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));\n    context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));\n    context.clip();\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @protected\n   */\n  prepareContainer(frameState, target) {\n    const extent = frameState.extent;\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const pixelRatio = frameState.pixelRatio;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n    // set forward and inverse pixel transforms\n    composeTransform(\n      this.pixelTransform,\n      frameState.size[0] / 2,\n      frameState.size[1] / 2,\n      1 / pixelRatio,\n      1 / pixelRatio,\n      rotation,\n      -width / 2,\n      -height / 2,\n    );\n    makeInverse(this.inversePixelTransform, this.pixelTransform);\n\n    const canvasTransform = toTransformString(this.pixelTransform);\n    this.useContainer(target, canvasTransform, this.getBackground(frameState));\n\n    if (!this.containerReused) {\n      const canvas = this.context.canvas;\n      if (canvas.width != width || canvas.height != height) {\n        canvas.width = width;\n        canvas.height = height;\n      } else {\n        this.context.clearRect(0, 0, width, height);\n      }\n      if (canvasTransform !== canvas.style.transform) {\n        canvas.style.transform = canvasTransform;\n      }\n    }\n  }\n\n  /**\n   * @param {import(\"../../render/EventType.js\").default} type Event type.\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  dispatchRenderEvent_(type, context, frameState) {\n    const layer = this.getLayer();\n    if (layer.hasListener(type)) {\n      const event = new RenderEvent(\n        type,\n        this.inversePixelTransform,\n        frameState,\n        context,\n      );\n      layer.dispatchEvent(event);\n    }\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  preRender(context, frameState) {\n    this.frameState = frameState;\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.PRERENDER, context, frameState);\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @protected\n   */\n  postRender(context, frameState) {\n    if (frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(RenderEventType.POSTRENDER, context, frameState);\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeferredInternal(frameState) {}\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import('../../render/canvas/ZIndexContext.js').ZIndexContextProxy} Context.\n   */\n  getRenderContext(frameState) {\n    if (frameState.declutter && !this.deferredContext_) {\n      this.deferredContext_ = new ZIndexContext();\n    }\n    return frameState.declutter\n      ? this.deferredContext_.getContext()\n      : this.context;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferred(frameState) {\n    if (!frameState.declutter) {\n      return;\n    }\n    this.dispatchRenderEvent_(\n      RenderEventType.PRERENDER,\n      this.context,\n      frameState,\n    );\n    if (frameState.declutter && this.deferredContext_) {\n      this.deferredContext_.draw(this.context);\n      this.deferredContext_.clear();\n    }\n    this.renderDeferredInternal(frameState);\n    this.dispatchRenderEvent_(\n      RenderEventType.POSTRENDER,\n      this.context,\n      frameState,\n    );\n  }\n\n  /**\n   * Creates a transform for rendering to an element that will be rotated after rendering.\n   * @param {import(\"../../coordinate.js\").Coordinate} center Center.\n   * @param {number} resolution Resolution.\n   * @param {number} rotation Rotation.\n   * @param {number} pixelRatio Pixel ratio.\n   * @param {number} width Width of the rendered element (in pixels).\n   * @param {number} height Height of the rendered element (in pixels).\n   * @param {number} offsetX Offset on the x-axis in view coordinates.\n   * @protected\n   * @return {!import(\"../../transform.js\").Transform} Transform.\n   */\n  getRenderTransform(\n    center,\n    resolution,\n    rotation,\n    pixelRatio,\n    width,\n    height,\n    offsetX,\n  ) {\n    const dx1 = width / 2;\n    const dy1 = height / 2;\n    const sx = pixelRatio / resolution;\n    const sy = -sx;\n    const dx2 = -center[0] + offsetX;\n    const dy2 = -center[1];\n    return composeTransform(\n      this.tempTransform,\n      dx1,\n      dy1,\n      sx,\n      sy,\n      -rotation,\n      dx2,\n      dy2,\n    );\n  }\n\n  /**\n   * Clean up.\n   * @override\n   */\n  disposeInternal() {\n    delete this.frameState;\n    super.disposeInternal();\n  }\n}\n\nexport default CanvasLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 812, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/canvas/TileLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/TileLayer\n */\nimport DataTile, {asImageLike} from '../../DataTile.js';\nimport ImageTile from '../../ImageTile.js';\nimport TileRange from '../../TileRange.js';\nimport TileState from '../../TileState.js';\nimport {ascending} from '../../array.js';\nimport {\n  containsCoordinate,\n  createEmpty,\n  equals,\n  getIntersection,\n  getRotatedViewport,\n  getTopLeft,\n  intersects,\n} from '../../extent.js';\nimport {fromUserExtent} from '../../proj.js';\nimport ReprojTile from '../../reproj/Tile.js';\nimport {toSize} from '../../size.js';\nimport LRUCache from '../../structs/LRUCache.js';\nimport {createOrUpdate as createTileCoord, getKeyZXY} from '../../tilecoord.js';\nimport {\n  apply as applyTransform,\n  compose as composeTransform,\n} from '../../transform.js';\nimport {getUid} from '../../util.js';\nimport CanvasLayerRenderer from './Layer.js';\n\n/**\n * @param {import(\"../../source/Tile.js\").default} source The tile source.\n * @param {string} sourceKey The source key.\n * @param {number} z The tile z level.\n * @param {number} x The tile x level.\n * @param {number} y The tile y level.\n * @return {string} The cache key.\n */\nfunction getCacheKey(source, sourceKey, z, x, y) {\n  return `${getUid(source)},${sourceKey},${getKeyZXY(z, x, y)}`;\n}\n\n/**\n * @typedef {Object<number, Set<import(\"../../Tile.js\").default>>} TileLookup\n */\n\n/**\n * Add a tile to the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was added to the lookup.\n */\nfunction addTileToLookup(tilesByZ, tile, z) {\n  if (!(z in tilesByZ)) {\n    tilesByZ[z] = new Set([tile]);\n    return true;\n  }\n  const set = tilesByZ[z];\n  const existing = set.has(tile);\n  if (!existing) {\n    set.add(tile);\n  }\n  return !existing;\n}\n\n/**\n * Remove a tile from the lookup.\n * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n * @param {import(\"../../Tile.js\").default} tile A tile.\n * @param {number} z The zoom level.\n * @return {boolean} The tile was removed from the lookup.\n */\nfunction removeTileFromLookup(tilesByZ, tile, z) {\n  const set = tilesByZ[z];\n  if (set) {\n    return set.delete(tile);\n  }\n  return false;\n}\n\n/**\n * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n * @param {import(\"../../extent.js\").Extent} extent The frame extent.\n * @return {import(\"../../extent.js\").Extent} Frame extent intersected with layer extents.\n */\nfunction getRenderExtent(frameState, extent) {\n  const layerState = frameState.layerStatesArray[frameState.layerIndex];\n  if (layerState.extent) {\n    extent = getIntersection(\n      extent,\n      fromUserExtent(layerState.extent, frameState.viewState.projection),\n    );\n  }\n  const source = /** @type {import(\"../../source/Tile.js\").default} */ (\n    layerState.layer.getRenderSource()\n  );\n  if (!source.getWrapX()) {\n    const gridExtent = source\n      .getTileGridForProjection(frameState.viewState.projection)\n      .getExtent();\n    if (gridExtent) {\n      extent = getIntersection(extent, gridExtent);\n    }\n  }\n  return extent;\n}\n\n/**\n * @typedef {Object} Options\n * @property {number} [cacheSize=512] The cache size.\n */\n\n/**\n * @classdesc\n * Canvas renderer for tile layers.\n * @api\n * @template {import(\"../../layer/Tile.js\").default|import(\"../../layer/VectorTile.js\").default} [LayerType=import(\"../../layer/Tile.js\").default<import(\"../../source/Tile.js\").default>|import(\"../../layer/VectorTile.js\").default]\n * @extends {CanvasLayerRenderer<LayerType>}\n */\nclass CanvasTileLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {LayerType} tileLayer Tile layer.\n   * @param {Options} [options] Options.\n   */\n  constructor(tileLayer, options) {\n    super(tileLayer);\n\n    options = options || {};\n\n    /**\n     * Rendered extent has changed since the previous `renderFrame()` call\n     * @type {boolean}\n     */\n    this.extentChanged = true;\n\n    /**\n     * The last call to `renderFrame` was completed with all tiles loaded\n     * @type {boolean}\n     */\n    this.renderComplete = false;\n\n    /**\n     * @private\n     * @type {?import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = null;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.renderedPixelRatio;\n\n    /**\n     * @protected\n     * @type {import(\"../../proj/Projection.js\").default|null}\n     */\n    this.renderedProjection = null;\n\n    /**\n     * @protected\n     * @type {!Array<import(\"../../Tile.js\").default>}\n     */\n    this.renderedTiles = [];\n\n    /**\n     * @private\n     * @type {string}\n     */\n    this.renderedSourceKey_;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedSourceRevision_;\n\n    /**\n     * @protected\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.tempExtent = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../TileRange.js\").default}\n     */\n    this.tempTileRange_ = new TileRange(0, 0, 0, 0);\n\n    /**\n     * @type {import(\"../../tilecoord.js\").TileCoord}\n     * @private\n     */\n    this.tempTileCoord_ = createTileCoord(0, 0, 0);\n\n    const cacheSize = options.cacheSize !== undefined ? options.cacheSize : 512;\n\n    /**\n     * @type {import(\"../../structs/LRUCache.js\").default<import(\"../../Tile.js\").default>}\n     * @private\n     */\n    this.tileCache_ = new LRUCache(cacheSize);\n\n    this.maxStaleKeys = cacheSize * 0.5;\n  }\n\n  /**\n   * @return {LRUCache} Tile cache.\n   */\n  getTileCache() {\n    return this.tileCache_;\n  }\n\n  /**\n   * Get a tile from the cache or create one if needed.\n   *\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getOrCreateTile(z, x, y, frameState) {\n    const tileCache = this.tileCache_;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const cacheKey = getCacheKey(tileSource, tileSource.getKey(), z, x, y);\n\n    /** @type {import(\"../../Tile.js\").default} */\n    let tile;\n\n    if (tileCache.containsKey(cacheKey)) {\n      tile = tileCache.get(cacheKey);\n    } else {\n      tile = tileSource.getTile(\n        z,\n        x,\n        y,\n        frameState.pixelRatio,\n        frameState.viewState.projection,\n      );\n      if (!tile) {\n        return null;\n      }\n      tileCache.set(cacheKey, tile);\n    }\n    return tile;\n  }\n\n  /**\n   * @param {number} z Tile coordinate z.\n   * @param {number} x Tile coordinate x.\n   * @param {number} y Tile coordinate y.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {import(\"../../Tile.js\").default|null} Tile (or null if outside source extent).\n   * @protected\n   */\n  getTile(z, x, y, frameState) {\n    const tile = this.getOrCreateTile(z, x, y, frameState);\n    if (!tile) {\n      return null;\n    }\n    return tile;\n  }\n\n  /**\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Uint8ClampedArray} Data at the pixel location.\n   * @override\n   */\n  getData(pixel) {\n    const frameState = this.frameState;\n    if (!frameState) {\n      return null;\n    }\n\n    const layer = this.getLayer();\n    const coordinate = applyTransform(\n      frameState.pixelToCoordinateTransform,\n      pixel.slice(),\n    );\n\n    const layerExtent = layer.getExtent();\n    if (layerExtent) {\n      if (!containsCoordinate(layerExtent, coordinate)) {\n        return null;\n      }\n    }\n\n    const viewState = frameState.viewState;\n    const source = layer.getRenderSource();\n    const tileGrid = source.getTileGridForProjection(viewState.projection);\n    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);\n\n    for (\n      let z = tileGrid.getZForResolution(viewState.resolution);\n      z >= tileGrid.getMinZoom();\n      --z\n    ) {\n      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);\n      const tile = this.getTile(z, tileCoord[1], tileCoord[2], frameState);\n      if (!tile || tile.getState() !== TileState.LOADED) {\n        continue;\n      }\n\n      const tileOrigin = tileGrid.getOrigin(z);\n      const tileSize = toSize(tileGrid.getTileSize(z));\n      const tileResolution = tileGrid.getResolution(z);\n\n      /**\n       * @type {import('../../DataTile.js').ImageLike}\n       */\n      let image;\n      if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n        image = tile.getImage();\n      } else if (tile instanceof DataTile) {\n        image = asImageLike(tile.getData());\n        if (!image) {\n          continue;\n        }\n      } else {\n        continue;\n      }\n\n      const col = Math.floor(\n        tilePixelRatio *\n          ((coordinate[0] - tileOrigin[0]) / tileResolution -\n            tileCoord[1] * tileSize[0]),\n      );\n\n      const row = Math.floor(\n        tilePixelRatio *\n          ((tileOrigin[1] - coordinate[1]) / tileResolution -\n            tileCoord[2] * tileSize[1]),\n      );\n\n      const gutter = Math.round(\n        tilePixelRatio * source.getGutterForProjection(viewState.projection),\n      );\n\n      return this.getImageData(image, col + gutter, row + gutter);\n    }\n\n    return null;\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    if (!this.renderedProjection) {\n      this.renderedProjection = frameState.viewState.projection;\n    } else if (frameState.viewState.projection !== this.renderedProjection) {\n      this.tileCache_.clear();\n      this.renderedProjection = frameState.viewState.projection;\n    }\n\n    const source = this.getLayer().getSource();\n    if (!source) {\n      return false;\n    }\n    const sourceRevision = source.getRevision();\n    if (!this.renderedSourceRevision_) {\n      this.renderedSourceRevision_ = sourceRevision;\n    } else if (this.renderedSourceRevision_ !== sourceRevision) {\n      this.renderedSourceRevision_ = sourceRevision;\n      if (this.renderedSourceKey_ === source.getKey()) {\n        this.tileCache_.clear();\n      }\n    }\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {import(\"../../extent.js\").Extent} extent The extent to be rendered.\n   * @param {number} initialZ The zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @param {number} preload Number of additional levels to load.\n   */\n  enqueueTiles(frameState, extent, initialZ, tilesByZ, preload) {\n    const viewState = frameState.viewState;\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getRenderSource();\n    const tileGrid = tileSource.getTileGridForProjection(viewState.projection);\n\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in frameState.wantedTiles)) {\n      frameState.wantedTiles[tileSourceKey] = {};\n    }\n\n    const wantedTiles = frameState.wantedTiles[tileSourceKey];\n\n    const map = tileLayer.getMapInternal();\n    const minZ = Math.max(\n      initialZ - preload,\n      tileGrid.getMinZoom(),\n      tileGrid.getZForResolution(\n        Math.min(\n          tileLayer.getMaxResolution(),\n          map\n            ? map\n                .getView()\n                .getResolutionForZoom(Math.max(tileLayer.getMinZoom(), 0))\n            : tileGrid.getResolution(0),\n        ),\n        tileSource.zDirection,\n      ),\n    );\n    const rotation = viewState.rotation;\n    const viewport = rotation\n      ? getRotatedViewport(\n          viewState.center,\n          viewState.resolution,\n          rotation,\n          frameState.size,\n        )\n      : undefined;\n    for (let z = initialZ; z >= minZ; --z) {\n      const tileRange = tileGrid.getTileRangeForExtentAndZ(\n        extent,\n        z,\n        this.tempTileRange_,\n      );\n\n      const tileResolution = tileGrid.getResolution(z);\n\n      for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n        for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n          if (\n            rotation &&\n            !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)\n          ) {\n            continue;\n          }\n          const tile = this.getTile(z, x, y, frameState);\n          if (!tile) {\n            continue;\n          }\n          const added = addTileToLookup(tilesByZ, tile, z);\n          if (!added) {\n            continue;\n          }\n\n          const tileQueueKey = tile.getKey();\n          wantedTiles[tileQueueKey] = true;\n\n          if (tile.getState() === TileState.IDLE) {\n            if (!frameState.tileQueue.isKeyQueued(tileQueueKey)) {\n              const tileCoord = createTileCoord(z, x, y, this.tempTileCoord_);\n              frameState.tileQueue.enqueue([\n                tile,\n                tileSourceKey,\n                tileGrid.getTileCoordCenter(tileCoord),\n                tileResolution,\n              ]);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findStaleTile_(tileCoord, tilesByZ) {\n    const tileCache = this.tileCache_;\n    const z = tileCoord[0];\n    const x = tileCoord[1];\n    const y = tileCoord[2];\n    const staleKeys = this.getStaleKeys();\n    for (let i = 0; i < staleKeys.length; ++i) {\n      const cacheKey = getCacheKey(\n        this.getLayer().getSource(),\n        staleKeys[i],\n        z,\n        x,\n        y,\n      );\n      if (tileCache.containsKey(cacheKey)) {\n        const tile = tileCache.peek(cacheKey);\n        if (tile.getState() === TileState.LOADED) {\n          tile.endTransition(getUid(this));\n          addTileToLookup(tilesByZ, tile, z);\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Look for tiles covering the provided tile coordinate at an alternate\n   * zoom level.  Loaded tiles will be added to the provided tile texture lookup.\n   * @param {import(\"../../tilegrid/TileGrid.js\").default} tileGrid The tile grid.\n   * @param {import(\"../../tilecoord.js\").TileCoord} tileCoord The target tile coordinate.\n   * @param {number} altZ The alternate zoom level.\n   * @param {TileLookup} tilesByZ Lookup of tiles by zoom level.\n   * @return {boolean} The tile coordinate is covered by loaded tiles at the alternate zoom level.\n   * @private\n   */\n  findAltTiles_(tileGrid, tileCoord, altZ, tilesByZ) {\n    const tileRange = tileGrid.getTileRangeForTileCoordAndZ(\n      tileCoord,\n      altZ,\n      this.tempTileRange_,\n    );\n\n    if (!tileRange) {\n      return false;\n    }\n\n    let covered = true;\n    const tileCache = this.tileCache_;\n    const source = this.getLayer().getRenderSource();\n    const sourceKey = source.getKey();\n    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {\n      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {\n        const cacheKey = getCacheKey(source, sourceKey, altZ, x, y);\n        let loaded = false;\n        if (tileCache.containsKey(cacheKey)) {\n          const tile = tileCache.peek(cacheKey);\n          if (tile.getState() === TileState.LOADED) {\n            addTileToLookup(tilesByZ, tile, altZ);\n            loaded = true;\n          }\n        }\n        if (!loaded) {\n          covered = false;\n        }\n      }\n    }\n    return covered;\n  }\n\n  /**\n   * Render the layer.\n   *\n   * The frame rendering logic has three parts:\n   *\n   *  1. Enqueue tiles\n   *  2. Find alt tiles for those that are not yet loaded\n   *  3. Render loaded tiles\n   *\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    this.renderComplete = true;\n\n    /**\n     * TODO:\n     *  maybe skip transition when not fully opaque\n     *  decide if this.renderComplete is useful\n     */\n\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const viewResolution = viewState.resolution;\n    const viewCenter = viewState.center;\n    const pixelRatio = frameState.pixelRatio;\n\n    const tileLayer = this.getLayer();\n    const tileSource = tileLayer.getSource();\n    const tileGrid = tileSource.getTileGridForProjection(projection);\n    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);\n    const tileResolution = tileGrid.getResolution(z);\n\n    const sourceKey = tileSource.getKey();\n    if (!this.renderedSourceKey_) {\n      this.renderedSourceKey_ = sourceKey;\n    } else if (this.renderedSourceKey_ !== sourceKey) {\n      this.prependStaleKey(this.renderedSourceKey_);\n      this.renderedSourceKey_ = sourceKey;\n    }\n\n    let frameExtent = frameState.extent;\n    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);\n\n    this.prepareContainer(frameState, target);\n\n    // desired dimensions of the canvas in pixels\n    const width = this.context.canvas.width;\n    const height = this.context.canvas.height;\n\n    const layerExtent =\n      layerState.extent && fromUserExtent(layerState.extent, projection);\n    if (layerExtent) {\n      frameExtent = getIntersection(\n        frameExtent,\n        fromUserExtent(layerState.extent, projection),\n      );\n    }\n\n    const dx = (tileResolution * width) / 2 / tilePixelRatio;\n    const dy = (tileResolution * height) / 2 / tilePixelRatio;\n    const canvasExtent = [\n      viewCenter[0] - dx,\n      viewCenter[1] - dy,\n      viewCenter[0] + dx,\n      viewCenter[1] + dy,\n    ];\n\n    /**\n     * @type {TileLookup}\n     */\n    const tilesByZ = {};\n\n    this.renderedTiles.length = 0;\n\n    /**\n     * Part 1: Enqueue tiles\n     */\n\n    const preload = tileLayer.getPreload();\n    if (frameState.nextExtent) {\n      const targetZ = tileGrid.getZForResolution(\n        viewState.nextResolution,\n        tileSource.zDirection,\n      );\n      const nextExtent = getRenderExtent(frameState, frameState.nextExtent);\n      this.enqueueTiles(frameState, nextExtent, targetZ, tilesByZ, preload);\n    }\n\n    const renderExtent = getRenderExtent(frameState, frameExtent);\n    this.enqueueTiles(frameState, renderExtent, z, tilesByZ, 0);\n    if (preload > 0) {\n      setTimeout(() => {\n        this.enqueueTiles(\n          frameState,\n          renderExtent,\n          z - 1,\n          tilesByZ,\n          preload - 1,\n        );\n      }, 0);\n    }\n\n    if (!(z in tilesByZ)) {\n      return this.container;\n    }\n\n    /**\n     * Part 2: Find alt tiles for those that are not yet loaded\n     */\n\n    const uid = getUid(this);\n    const time = frameState.time;\n\n    // look for cached tiles to use if a target tile is not ready\n    for (const tile of tilesByZ[z]) {\n      const tileState = tile.getState();\n      if (tileState === TileState.EMPTY) {\n        continue;\n      }\n      const tileCoord = tile.tileCoord;\n\n      if (tileState === TileState.LOADED) {\n        const alpha = tile.getAlpha(uid, time);\n        if (alpha === 1) {\n          // no need to look for alt tiles\n          tile.endTransition(uid);\n          continue;\n        }\n      }\n      if (tileState !== TileState.ERROR) {\n        this.renderComplete = false;\n      }\n\n      const hasStaleTile = this.findStaleTile_(tileCoord, tilesByZ);\n      if (hasStaleTile) {\n        // use the stale tile before the new tile's transition has completed\n        removeTileFromLookup(tilesByZ, tile, z);\n        frameState.animate = true;\n        continue;\n      }\n\n      // first look for child tiles (at z + 1)\n      const coveredByChildren = this.findAltTiles_(\n        tileGrid,\n        tileCoord,\n        z + 1,\n        tilesByZ,\n      );\n\n      if (coveredByChildren) {\n        continue;\n      }\n\n      // next look for parent tiles\n      const minZoom = tileGrid.getMinZoom();\n      for (let parentZ = z - 1; parentZ >= minZoom; --parentZ) {\n        const coveredByParent = this.findAltTiles_(\n          tileGrid,\n          tileCoord,\n          parentZ,\n          tilesByZ,\n        );\n\n        if (coveredByParent) {\n          break;\n        }\n      }\n    }\n\n    /**\n     * Part 3: Render loaded tiles\n     */\n\n    const canvasScale =\n      ((tileResolution / viewResolution) * pixelRatio) / tilePixelRatio;\n\n    const context = this.getRenderContext(frameState);\n\n    // set scale transform for calculating tile positions on the canvas\n    composeTransform(\n      this.tempTransform,\n      width / 2,\n      height / 2,\n      canvasScale,\n      canvasScale,\n      0,\n      -width / 2,\n      -height / 2,\n    );\n\n    if (layerState.extent) {\n      this.clipUnrotated(context, frameState, layerExtent);\n    }\n\n    if (!tileSource.getInterpolate()) {\n      context.imageSmoothingEnabled = false;\n    }\n\n    this.preRender(context, frameState);\n\n    /** @type {Array<number>} */\n    const zs = Object.keys(tilesByZ).map(Number);\n    zs.sort(ascending);\n\n    let currentClip;\n    const clips = [];\n    const clipZs = [];\n    for (let i = zs.length - 1; i >= 0; --i) {\n      const currentZ = zs[i];\n      const currentTilePixelSize = tileSource.getTilePixelSize(\n        currentZ,\n        pixelRatio,\n        projection,\n      );\n      const currentResolution = tileGrid.getResolution(currentZ);\n      const currentScale = currentResolution / tileResolution;\n      const dx = currentTilePixelSize[0] * currentScale * canvasScale;\n      const dy = currentTilePixelSize[1] * currentScale * canvasScale;\n      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(\n        getTopLeft(canvasExtent),\n        currentZ,\n      );\n      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);\n      const origin = applyTransform(this.tempTransform, [\n        (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /\n          tileResolution,\n        (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /\n          tileResolution,\n      ]);\n      const tileGutter =\n        tilePixelRatio * tileSource.getGutterForProjection(projection);\n      for (const tile of tilesByZ[currentZ]) {\n        if (tile.getState() !== TileState.LOADED) {\n          continue;\n        }\n        const tileCoord = tile.tileCoord;\n\n        // Calculate integer positions and sizes so that tiles align\n        const xIndex = originTileCoord[1] - tileCoord[1];\n        const nextX = Math.round(origin[0] - (xIndex - 1) * dx);\n        const yIndex = originTileCoord[2] - tileCoord[2];\n        const nextY = Math.round(origin[1] - (yIndex - 1) * dy);\n        const x = Math.round(origin[0] - xIndex * dx);\n        const y = Math.round(origin[1] - yIndex * dy);\n        const w = nextX - x;\n        const h = nextY - y;\n        const transition = zs.length === 1;\n\n        let contextSaved = false;\n\n        // Clip mask for regions in this tile that already filled by a higher z tile\n        currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];\n        for (let i = 0, ii = clips.length; i < ii; ++i) {\n          if (!transition && currentZ < clipZs[i]) {\n            const clip = clips[i];\n            if (\n              intersects(\n                [x, y, x + w, y + h],\n                [clip[0], clip[3], clip[4], clip[7]],\n              )\n            ) {\n              if (!contextSaved) {\n                context.save();\n                contextSaved = true;\n              }\n              context.beginPath();\n              // counter-clockwise (outer ring) for current tile\n              context.moveTo(currentClip[0], currentClip[1]);\n              context.lineTo(currentClip[2], currentClip[3]);\n              context.lineTo(currentClip[4], currentClip[5]);\n              context.lineTo(currentClip[6], currentClip[7]);\n              // clockwise (inner ring) for higher z tile\n              context.moveTo(clip[6], clip[7]);\n              context.lineTo(clip[4], clip[5]);\n              context.lineTo(clip[2], clip[3]);\n              context.lineTo(clip[0], clip[1]);\n              context.clip();\n            }\n          }\n        }\n        clips.push(currentClip);\n        clipZs.push(currentZ);\n\n        this.drawTile(tile, frameState, x, y, w, h, tileGutter, transition);\n        if (contextSaved) {\n          context.restore();\n        }\n        this.renderedTiles.unshift(tile);\n\n        // TODO: decide if this is necessary\n        this.updateUsedTiles(frameState.usedTiles, tileSource, tile);\n      }\n    }\n\n    this.renderedResolution = tileResolution;\n    this.extentChanged =\n      !this.renderedExtent_ || !equals(this.renderedExtent_, canvasExtent);\n    this.renderedExtent_ = canvasExtent;\n    this.renderedPixelRatio = pixelRatio;\n\n    this.postRender(this.context, frameState);\n\n    if (layerState.extent) {\n      context.restore();\n    }\n    context.imageSmoothingEnabled = true;\n\n    if (this.renderComplete) {\n      /**\n       * @param {import(\"../../Map.js\").default} map Map.\n       * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n       */\n      const postRenderFunction = (map, frameState) => {\n        const tileSourceKey = getUid(tileSource);\n        const wantedTiles = frameState.wantedTiles[tileSourceKey];\n        const tilesCount = wantedTiles ? Object.keys(wantedTiles).length : 0;\n        this.updateCacheSize(tilesCount);\n        this.tileCache_.expireCache();\n      };\n\n      frameState.postRenderFunctions.push(postRenderFunction);\n    }\n\n    return this.container;\n  }\n\n  /**\n   * Increases the cache size if needed\n   * @param {number} tileCount Minimum number of tiles needed.\n   */\n  updateCacheSize(tileCount) {\n    this.tileCache_.highWaterMark = Math.max(\n      this.tileCache_.highWaterMark,\n      tileCount * 2,\n    );\n  }\n\n  /**\n   * @param {import(\"../../Tile.js\").default} tile Tile.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} x Left of the tile.\n   * @param {number} y Top of the tile.\n   * @param {number} w Width of the tile.\n   * @param {number} h Height of the tile.\n   * @param {number} gutter Tile gutter.\n   * @param {boolean} transition Apply an alpha transition.\n   * @protected\n   */\n  drawTile(tile, frameState, x, y, w, h, gutter, transition) {\n    let image;\n    if (tile instanceof DataTile) {\n      image = asImageLike(tile.getData());\n      if (!image) {\n        throw new Error('Rendering array data is not yet supported');\n      }\n    } else {\n      image = this.getTileImage(\n        /** @type {import(\"../../ImageTile.js\").default} */ (tile),\n      );\n    }\n    if (!image) {\n      return;\n    }\n    const context = this.getRenderContext(frameState);\n    const uid = getUid(this);\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const alpha =\n      layerState.opacity *\n      (transition ? tile.getAlpha(uid, frameState.time) : 1);\n    const alphaChanged = alpha !== context.globalAlpha;\n    if (alphaChanged) {\n      context.save();\n      context.globalAlpha = alpha;\n    }\n    context.drawImage(\n      image,\n      gutter,\n      gutter,\n      image.width - 2 * gutter,\n      image.height - 2 * gutter,\n      x,\n      y,\n      w,\n      h,\n    );\n\n    if (alphaChanged) {\n      context.restore();\n    }\n    if (alpha !== layerState.opacity) {\n      frameState.animate = true;\n    } else if (transition) {\n      tile.endTransition(uid);\n    }\n  }\n\n  /**\n   * @return {HTMLCanvasElement} Image\n   */\n  getImage() {\n    const context = this.context;\n    return context ? context.canvas : null;\n  }\n\n  /**\n   * Get the image from a tile.\n   * @param {import(\"../../ImageTile.js\").default} tile Tile.\n   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.\n   * @protected\n   */\n  getTileImage(tile) {\n    return tile.getImage();\n  }\n\n  /**\n   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.\n   * @param {import(\"../../source/Tile.js\").default} tileSource Tile source.\n   * @param {import('../../Tile.js').default} tile Tile.\n   * @protected\n   */\n  updateUsedTiles(usedTiles, tileSource, tile) {\n    // FIXME should we use tilesToDrawByZ instead?\n    const tileSourceKey = getUid(tileSource);\n    if (!(tileSourceKey in usedTiles)) {\n      usedTiles[tileSourceKey] = {};\n    }\n    usedTiles[tileSourceKey][tile.getKey()] = true;\n  }\n}\n\nexport default CanvasTileLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1545, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/vector.js"],"sourcesContent":["/**\n * @module ol/renderer/vector\n */\nimport ImageState from '../ImageState.js';\nimport {getUid} from '../util.js';\n\n/**\n * Feature callback. The callback will be called with three arguments. The first\n * argument is one {@link module:ol/Feature~Feature feature} or {@link module:ol/render/Feature~RenderFeature render feature}\n * at the pixel, the second is the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for\n * unmanaged layers. The third is the {@link module:ol/geom/SimpleGeometry~SimpleGeometry} of the feature. For features\n * with a GeometryCollection geometry, it will be the first detected geometry from the collection.\n * @template T\n * @typedef {function(import(\"../Feature.js\").FeatureLike, import(\"../layer/Layer.js\").default<import(\"../source/Source\").default>, import(\"../geom/SimpleGeometry.js\").default): T} FeatureCallback\n */\n\n/**\n * Tolerance for geometry simplification in device pixels.\n * @type {number}\n */\nconst SIMPLIFY_TOLERANCE = 0.5;\n\n/**\n * @const\n * @type {Object<import(\"../geom/Geometry.js\").Type,\n *                function(import(\"../render/canvas/BuilderGroup.js\").default, import(\"../geom/Geometry.js\").default,\n *                         import(\"../style/Style.js\").default, Object): void>}\n */\nconst GEOMETRY_RENDERERS = {\n  'Point': renderPointGeometry,\n  'LineString': renderLineStringGeometry,\n  'Polygon': renderPolygonGeometry,\n  'MultiPoint': renderMultiPointGeometry,\n  'MultiLineString': renderMultiLineStringGeometry,\n  'MultiPolygon': renderMultiPolygonGeometry,\n  'GeometryCollection': renderGeometryCollectionGeometry,\n  'Circle': renderCircleGeometry,\n};\n\n/**\n * @param {import(\"../Feature.js\").FeatureLike} feature1 Feature 1.\n * @param {import(\"../Feature.js\").FeatureLike} feature2 Feature 2.\n * @return {number} Order.\n */\nexport function defaultOrder(feature1, feature2) {\n  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Squared pixel tolerance.\n */\nexport function getSquaredTolerance(resolution, pixelRatio) {\n  const tolerance = getTolerance(resolution, pixelRatio);\n  return tolerance * tolerance;\n}\n\n/**\n * @param {number} resolution Resolution.\n * @param {number} pixelRatio Pixel ratio.\n * @return {number} Pixel tolerance.\n */\nexport function getTolerance(resolution, pixelRatio) {\n  return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n * @param {import(\"../geom/Circle.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderCircleGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const circleReplay = builderGroup.getBuilder(style.getZIndex(), 'Circle');\n    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    circleReplay.drawCircle(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {function(import(\"../events/Event.js\").default): void} listener Listener function.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n * @return {boolean} `true` if style is loading.\n */\nexport function renderFeature(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  listener,\n  transform,\n  declutter,\n  index,\n) {\n  const loadingPromises = [];\n  const imageStyle = style.getImage();\n  if (imageStyle) {\n    let loading = true;\n    const imageState = imageStyle.getImageState();\n    if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {\n      loading = false;\n    } else {\n      if (imageState == ImageState.IDLE) {\n        imageStyle.load();\n      }\n    }\n    if (loading) {\n      loadingPromises.push(imageStyle.ready());\n    }\n  }\n  const fillStyle = style.getFill();\n  if (fillStyle && fillStyle.loading()) {\n    loadingPromises.push(fillStyle.ready());\n  }\n  const loading = loadingPromises.length > 0;\n  if (loading) {\n    Promise.all(loadingPromises).then(() => listener(null));\n  }\n  renderFeatureInternal(\n    replayGroup,\n    feature,\n    style,\n    squaredTolerance,\n    transform,\n    declutter,\n    index,\n  );\n\n  return loading;\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {import(\"../proj.js\").TransformFunction} [transform] Optional transform function.\n * @param {boolean} [declutter] Enable decluttering.\n * @param {number} [index] Render order index..\n */\nfunction renderFeatureInternal(\n  replayGroup,\n  feature,\n  style,\n  squaredTolerance,\n  transform,\n  declutter,\n  index,\n) {\n  const geometry = style.getGeometryFunction()(feature);\n  if (!geometry) {\n    return;\n  }\n  const simplifiedGeometry = geometry.simplifyTransformed(\n    squaredTolerance,\n    transform,\n  );\n  const renderer = style.getRenderer();\n  if (renderer) {\n    renderGeometry(replayGroup, simplifiedGeometry, style, feature, index);\n  } else {\n    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];\n    geometryRenderer(\n      replayGroup,\n      simplifiedGeometry,\n      style,\n      feature,\n      index,\n      declutter,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/Geometry.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometry(replayGroup, geometry, style, feature, index) {\n  if (geometry.getType() == 'GeometryCollection') {\n    const geometries =\n      /** @type {import(\"../geom/GeometryCollection.js\").default} */ (\n        geometry\n      ).getGeometries();\n    for (let i = 0, ii = geometries.length; i < ii; ++i) {\n      renderGeometry(replayGroup, geometries[i], style, feature, index);\n    }\n    return;\n  }\n  const replay = replayGroup.getBuilder(style.getZIndex(), 'Default');\n  replay.drawCustom(\n    /** @type {import(\"../geom/SimpleGeometry.js\").default} */ (geometry),\n    feature,\n    style.getRenderer(),\n    style.getHitDetectionRenderer(),\n    index,\n  );\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} replayGroup Replay group.\n * @param {import(\"../geom/GeometryCollection.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} [declutterBuilderGroup] Builder for decluttering.\n * @param {number} [index] Render order index.\n */\nfunction renderGeometryCollectionGeometry(\n  replayGroup,\n  geometry,\n  style,\n  feature,\n  declutterBuilderGroup,\n  index,\n) {\n  const geometries = geometry.getGeometriesArray();\n  let i, ii;\n  for (i = 0, ii = geometries.length; i < ii; ++i) {\n    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];\n    geometryRenderer(\n      replayGroup,\n      geometries[i],\n      style,\n      feature,\n      declutterBuilderGroup,\n      index,\n    );\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/LineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiLineString.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiLineStringGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const strokeStyle = style.getStroke();\n  if (strokeStyle) {\n    const lineStringReplay = builderGroup.getBuilder(\n      style.getZIndex(),\n      'LineString',\n    );\n    lineStringReplay.setFillStrokeStyle(null, strokeStyle);\n    lineStringReplay.drawMultiLineString(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPolygon.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").default} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderMultiPolygonGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (strokeStyle || fillStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawMultiPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Point.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && imageStyle && hasText ? {} : undefined;\n  if (imageStyle) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/MultiPoint.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n * @param {boolean} [declutter] Enable decluttering.\n */\nfunction renderMultiPointGeometry(\n  builderGroup,\n  geometry,\n  style,\n  feature,\n  index,\n  declutter,\n) {\n  const imageStyle = style.getImage();\n  const hasImage = imageStyle && imageStyle.getOpacity() !== 0;\n  const textStyle = style.getText();\n  const hasText = textStyle && textStyle.getText();\n  /** @type {import(\"../render/canvas.js\").DeclutterImageWithText} */\n  const declutterImageWithText =\n    declutter && hasImage && hasText ? {} : undefined;\n  if (hasImage) {\n    if (imageStyle.getImageState() != ImageState.LOADED) {\n      return;\n    }\n    const imageReplay = builderGroup.getBuilder(style.getZIndex(), 'Image');\n    imageReplay.setImageStyle(imageStyle, declutterImageWithText);\n    imageReplay.drawMultiPoint(geometry, feature, index);\n  }\n  if (hasText) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle, declutterImageWithText);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n\n/**\n * @param {import(\"../render/canvas/BuilderGroup.js\").default} builderGroup Replay group.\n * @param {import(\"../geom/Polygon.js\").default|import(\"../render/Feature.js\").default} geometry Geometry.\n * @param {import(\"../style/Style.js\").default} style Style.\n * @param {import(\"../Feature.js\").FeatureLike} feature Feature.\n * @param {number} [index] Render order index.\n */\nfunction renderPolygonGeometry(builderGroup, geometry, style, feature, index) {\n  const fillStyle = style.getFill();\n  const strokeStyle = style.getStroke();\n  if (fillStyle || strokeStyle) {\n    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), 'Polygon');\n    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);\n    polygonReplay.drawPolygon(geometry, feature, index);\n  }\n  const textStyle = style.getText();\n  if (textStyle && textStyle.getText()) {\n    const textReplay = builderGroup.getBuilder(style.getZIndex(), 'Text');\n    textReplay.setTextStyle(textStyle);\n    textReplay.drawText(geometry, feature, index);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1840, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nixon/Documents/Programming%20Language/Project/job_portal/client/node_modules/ol/renderer/canvas/VectorLayer.js"],"sourcesContent":["/**\n * @module ol/renderer/canvas/VectorLayer\n */\nimport ViewHint from '../../ViewHint.js';\nimport {equals} from '../../array.js';\nimport {wrapX as wrapCoordinateX} from '../../coordinate.js';\nimport {createCanvasContext2D, releaseCanvas} from '../../dom.js';\nimport {\n  buffer,\n  containsExtent,\n  createEmpty,\n  getHeight,\n  getWidth,\n  intersects as intersectsExtent,\n  wrapX as wrapExtentX,\n} from '../../extent.js';\nimport {\n  fromUserExtent,\n  getTransformFromProjections,\n  getUserProjection,\n  toUserExtent,\n  toUserResolution,\n} from '../../proj.js';\nimport RenderEventType from '../../render/EventType.js';\nimport CanvasBuilderGroup from '../../render/canvas/BuilderGroup.js';\nimport ExecutorGroup, {\n  ALL,\n  DECLUTTER,\n  NON_DECLUTTER,\n} from '../../render/canvas/ExecutorGroup.js';\nimport {\n  HIT_DETECT_RESOLUTION,\n  createHitDetectionImageData,\n  hitDetect,\n} from '../../render/canvas/hitdetect.js';\nimport {getUid} from '../../util.js';\nimport {\n  defaultOrder as defaultRenderOrder,\n  getSquaredTolerance as getSquaredRenderTolerance,\n  getTolerance as getRenderTolerance,\n  renderFeature,\n} from '../vector.js';\nimport CanvasLayerRenderer, {canvasPool} from './Layer.js';\n\n/**\n * @classdesc\n * Canvas renderer for vector layers.\n * @api\n */\nclass CanvasVectorLayerRenderer extends CanvasLayerRenderer {\n  /**\n   * @param {import(\"../../layer/BaseVector.js\").default} vectorLayer Vector layer.\n   */\n  constructor(vectorLayer) {\n    super(vectorLayer);\n\n    /** @private */\n    this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.animatingOrInteracting_;\n\n    /**\n     * @private\n     * @type {ImageData|null}\n     */\n    this.hitDetectionImageData_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.clipped_ = false;\n\n    /**\n     * @private\n     * @type {Array<import(\"../../Feature.js\").default>}\n     */\n    this.renderedFeatures_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedResolution_ = NaN;\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.renderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {import(\"../../extent.js\").Extent}\n     */\n    this.wrappedRenderedExtent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedRotation_;\n\n    /**\n     * @private\n     * @type {import(\"../../coordinate\").Coordinate}\n     */\n    this.renderedCenter_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../../proj/Projection\").default}\n     */\n    this.renderedProjection_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.renderedPixelRatio_ = 1;\n\n    /**\n     * @private\n     * @type {import(\"../../render.js\").OrderFunction|null}\n     */\n    this.renderedRenderOrder_ = null;\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderedFrameDeclutter_;\n\n    /**\n     * @private\n     * @type {import(\"../../render/canvas/ExecutorGroup\").default}\n     */\n    this.replayGroup_ = null;\n\n    /**\n     * A new replay group had to be created by `prepareFrame()`\n     * @type {boolean}\n     */\n    this.replayGroupChanged = true;\n\n    /**\n     * Clipping to be performed by `renderFrame()`\n     * @type {boolean}\n     */\n    this.clipping = true;\n\n    /**\n     * @private\n     * @type {CanvasRenderingContext2D}\n     */\n    this.targetContext_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.opacity_ = 1;\n  }\n\n  /**\n   * @param {ExecutorGroup} executorGroup Executor group.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {boolean} [declutterable] `true` to only render declutterable items,\n   *     `false` to only render non-declutterable items, `undefined` to render all.\n   */\n  renderWorlds(executorGroup, frameState, declutterable) {\n    const extent = frameState.extent;\n    const viewState = frameState.viewState;\n    const center = viewState.center;\n    const resolution = viewState.resolution;\n    const projection = viewState.projection;\n    const rotation = viewState.rotation;\n    const projectionExtent = projection.getExtent();\n    const vectorSource = this.getLayer().getSource();\n    const declutter = this.getLayer().getDeclutter();\n    const pixelRatio = frameState.pixelRatio;\n    const viewHints = frameState.viewHints;\n    const snapToPixel = !(\n      viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]\n    );\n    const context = this.context;\n    const width = Math.round((getWidth(extent) / resolution) * pixelRatio);\n    const height = Math.round((getHeight(extent) / resolution) * pixelRatio);\n\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n    do {\n      let transform = this.getRenderTransform(\n        center,\n        resolution,\n        0,\n        pixelRatio,\n        width,\n        height,\n        world * worldWidth,\n      );\n      if (frameState.declutter) {\n        transform = transform.slice(0);\n      }\n      executorGroup.execute(\n        context,\n        [context.canvas.width, context.canvas.height],\n        transform,\n        rotation,\n        snapToPixel,\n        declutterable === undefined\n          ? ALL\n          : declutterable\n            ? DECLUTTER\n            : NON_DECLUTTER,\n        declutterable\n          ? declutter && frameState.declutter[declutter]\n          : undefined,\n      );\n    } while (++world < endWorld);\n  }\n\n  /**\n   * @private\n   */\n  setDrawContext_() {\n    if (this.opacity_ !== 1) {\n      this.targetContext_ = this.context;\n      this.context = createCanvasContext2D(\n        this.context.canvas.width,\n        this.context.canvas.height,\n        canvasPool,\n      );\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetDrawContext_() {\n    if (this.opacity_ !== 1 && this.targetContext_) {\n      const alpha = this.targetContext_.globalAlpha;\n      this.targetContext_.globalAlpha = this.opacity_;\n      this.targetContext_.drawImage(this.context.canvas, 0, 0);\n      this.targetContext_.globalAlpha = alpha;\n      releaseCanvas(this.context);\n      canvasPool.push(this.context.canvas);\n      this.context = this.targetContext_;\n      this.targetContext_ = null;\n    }\n  }\n\n  /**\n   * Render declutter items for this layer\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   */\n  renderDeclutter(frameState) {\n    if (!this.replayGroup_ || !this.getLayer().getDeclutter()) {\n      return;\n    }\n    this.renderWorlds(this.replayGroup_, frameState, true);\n  }\n\n  /**\n   * Render deferred instructions.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @override\n   */\n  renderDeferredInternal(frameState) {\n    if (!this.replayGroup_) {\n      return;\n    }\n    this.replayGroup_.renderDeferred();\n    if (this.clipped_) {\n      this.context.restore();\n    }\n    this.resetDrawContext_();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {HTMLElement|null} target Target that may be used to render content to.\n   * @return {HTMLElement} The rendered element.\n   * @override\n   */\n  renderFrame(frameState, target) {\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    this.opacity_ = layerState.opacity;\n    const viewState = frameState.viewState;\n\n    this.prepareContainer(frameState, target);\n    const context = this.context;\n\n    const replayGroup = this.replayGroup_;\n    let render = replayGroup && !replayGroup.isEmpty();\n    if (!render) {\n      const hasRenderListeners =\n        this.getLayer().hasListener(RenderEventType.PRERENDER) ||\n        this.getLayer().hasListener(RenderEventType.POSTRENDER);\n      if (!hasRenderListeners) {\n        return this.container;\n      }\n    }\n\n    this.setDrawContext_();\n\n    this.preRender(context, frameState);\n\n    const projection = viewState.projection;\n\n    // clipped rendering if layer extent is set\n    this.clipped_ = false;\n    if (render && layerState.extent && this.clipping) {\n      const layerExtent = fromUserExtent(layerState.extent, projection);\n      render = intersectsExtent(layerExtent, frameState.extent);\n      this.clipped_ = render && !containsExtent(layerExtent, frameState.extent);\n      if (this.clipped_) {\n        this.clipUnrotated(context, frameState, layerExtent);\n      }\n    }\n\n    if (render) {\n      this.renderWorlds(\n        replayGroup,\n        frameState,\n        this.getLayer().getDeclutter() ? false : undefined,\n      );\n    }\n\n    if (!frameState.declutter && this.clipped_) {\n      context.restore();\n    }\n\n    this.postRender(context, frameState);\n\n    if (this.renderedRotation_ !== viewState.rotation) {\n      this.renderedRotation_ = viewState.rotation;\n      this.hitDetectionImageData_ = null;\n    }\n    if (!frameState.declutter) {\n      this.resetDrawContext_();\n    }\n    return this.container;\n  }\n\n  /**\n   * Asynchronous layer level hit detection.\n   * @param {import(\"../../pixel.js\").Pixel} pixel Pixel.\n   * @return {Promise<Array<import(\"../../Feature\").default>>} Promise\n   * that resolves with an array of features.\n   * @override\n   */\n  getFeatures(pixel) {\n    return new Promise((resolve) => {\n      if (\n        this.frameState &&\n        !this.hitDetectionImageData_ &&\n        !this.animatingOrInteracting_\n      ) {\n        const size = this.frameState.size.slice();\n        const center = this.renderedCenter_;\n        const resolution = this.renderedResolution_;\n        const rotation = this.renderedRotation_;\n        const projection = this.renderedProjection_;\n        const extent = this.wrappedRenderedExtent_;\n        const layer = this.getLayer();\n        const transforms = [];\n        const width = size[0] * HIT_DETECT_RESOLUTION;\n        const height = size[1] * HIT_DETECT_RESOLUTION;\n        transforms.push(\n          this.getRenderTransform(\n            center,\n            resolution,\n            rotation,\n            HIT_DETECT_RESOLUTION,\n            width,\n            height,\n            0,\n          ).slice(),\n        );\n        const source = layer.getSource();\n        const projectionExtent = projection.getExtent();\n        if (\n          source.getWrapX() &&\n          projection.canWrapX() &&\n          !containsExtent(projectionExtent, extent)\n        ) {\n          let startX = extent[0];\n          const worldWidth = getWidth(projectionExtent);\n          let world = 0;\n          let offsetX;\n          while (startX < projectionExtent[0]) {\n            --world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX += worldWidth;\n          }\n          world = 0;\n          startX = extent[2];\n          while (startX > projectionExtent[2]) {\n            ++world;\n            offsetX = worldWidth * world;\n            transforms.push(\n              this.getRenderTransform(\n                center,\n                resolution,\n                rotation,\n                HIT_DETECT_RESOLUTION,\n                width,\n                height,\n                offsetX,\n              ).slice(),\n            );\n            startX -= worldWidth;\n          }\n        }\n        const userProjection = getUserProjection();\n        this.hitDetectionImageData_ = createHitDetectionImageData(\n          size,\n          transforms,\n          this.renderedFeatures_,\n          layer.getStyleFunction(),\n          extent,\n          resolution,\n          rotation,\n          getSquaredRenderTolerance(resolution, this.renderedPixelRatio_),\n          userProjection ? projection : null,\n        );\n      }\n      resolve(\n        hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_),\n      );\n    });\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   * @override\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches,\n  ) {\n    if (!this.replayGroup_) {\n      return undefined;\n    }\n    const resolution = frameState.viewState.resolution;\n    const rotation = frameState.viewState.rotation;\n    const layer = this.getLayer();\n\n    /** @type {!Object<string, import(\"../Map.js\").HitMatch<T>|true>} */\n    const features = {};\n\n    /**\n     * @param {import(\"../../Feature.js\").FeatureLike} feature Feature.\n     * @param {import(\"../../geom/SimpleGeometry.js\").default} geometry Geometry.\n     * @param {number} distanceSq The squared distance to the click position\n     * @return {T|undefined} Callback result.\n     */\n    const featureCallback = function (feature, geometry, distanceSq) {\n      const key = getUid(feature);\n      const match = features[key];\n      if (!match) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          return callback(feature, layer, geometry);\n        }\n        matches.push(\n          (features[key] = {\n            feature: feature,\n            layer: layer,\n            geometry: geometry,\n            distanceSq: distanceSq,\n            callback: callback,\n          }),\n        );\n      } else if (match !== true && distanceSq < match.distanceSq) {\n        if (distanceSq === 0) {\n          features[key] = true;\n          matches.splice(matches.lastIndexOf(match), 1);\n          return callback(feature, layer, geometry);\n        }\n        match.geometry = geometry;\n        match.distanceSq = distanceSq;\n      }\n      return undefined;\n    };\n\n    const declutter = this.getLayer().getDeclutter();\n    return this.replayGroup_.forEachFeatureAtCoordinate(\n      coordinate,\n      resolution,\n      rotation,\n      hitTolerance,\n      featureCallback,\n      declutter\n        ? frameState.declutter?.[declutter]?.all().map((item) => item.value)\n        : null,\n    );\n  }\n\n  /**\n   * Perform action necessary to get the layer rendered after new fonts have loaded\n   * @override\n   */\n  handleFontsChanged() {\n    const layer = this.getLayer();\n    if (layer.getVisible() && this.replayGroup_) {\n      layer.changed();\n    }\n  }\n\n  /**\n   * Handle changes in image style state.\n   * @param {import(\"../../events/Event.js\").default} event Image style change event.\n   * @private\n   */\n  handleStyleImageChange_(event) {\n    this.renderIfReadyAndVisible();\n  }\n\n  /**\n   * Determine whether render should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   * @override\n   */\n  prepareFrame(frameState) {\n    const vectorLayer = this.getLayer();\n    const vectorSource = vectorLayer.getSource();\n    if (!vectorSource) {\n      return false;\n    }\n\n    const animating = frameState.viewHints[ViewHint.ANIMATING];\n    const interacting = frameState.viewHints[ViewHint.INTERACTING];\n    const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();\n    const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();\n\n    if (\n      (this.ready && !updateWhileAnimating && animating) ||\n      (!updateWhileInteracting && interacting)\n    ) {\n      this.animatingOrInteracting_ = true;\n      return true;\n    }\n    this.animatingOrInteracting_ = false;\n\n    const frameStateExtent = frameState.extent;\n    const viewState = frameState.viewState;\n    const projection = viewState.projection;\n    const resolution = viewState.resolution;\n    const pixelRatio = frameState.pixelRatio;\n    const vectorLayerRevision = vectorLayer.getRevision();\n    const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();\n    let vectorLayerRenderOrder = vectorLayer.getRenderOrder();\n\n    if (vectorLayerRenderOrder === undefined) {\n      vectorLayerRenderOrder = defaultRenderOrder;\n    }\n\n    const center = viewState.center.slice();\n    const extent = buffer(\n      frameStateExtent,\n      vectorLayerRenderBuffer * resolution,\n    );\n    const renderedExtent = extent.slice();\n    const loadExtents = [extent.slice()];\n    const projectionExtent = projection.getExtent();\n\n    if (\n      vectorSource.getWrapX() &&\n      projection.canWrapX() &&\n      !containsExtent(projectionExtent, frameState.extent)\n    ) {\n      // For the replay group, we need an extent that intersects the real world\n      // (-180° to +180°). To support geometries in a coordinate range from -540°\n      // to +540°, we add at least 1 world width on each side of the projection\n      // extent. If the viewport is wider than the world, we need to add half of\n      // the viewport width to make sure we cover the whole viewport.\n      const worldWidth = getWidth(projectionExtent);\n      const gutter = Math.max(getWidth(extent) / 2, worldWidth);\n      extent[0] = projectionExtent[0] - gutter;\n      extent[2] = projectionExtent[2] + gutter;\n      wrapCoordinateX(center, projection);\n      const loadExtent = wrapExtentX(loadExtents[0], projection);\n      // If the extent crosses the date line, we load data for both edges of the worlds\n      if (\n        loadExtent[0] < projectionExtent[0] &&\n        loadExtent[2] < projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] + worldWidth,\n          loadExtent[1],\n          loadExtent[2] + worldWidth,\n          loadExtent[3],\n        ]);\n      } else if (\n        loadExtent[0] > projectionExtent[0] &&\n        loadExtent[2] > projectionExtent[2]\n      ) {\n        loadExtents.push([\n          loadExtent[0] - worldWidth,\n          loadExtent[1],\n          loadExtent[2] - worldWidth,\n          loadExtent[3],\n        ]);\n      }\n    }\n\n    if (\n      this.ready &&\n      this.renderedResolution_ == resolution &&\n      this.renderedRevision_ == vectorLayerRevision &&\n      this.renderedRenderOrder_ == vectorLayerRenderOrder &&\n      this.renderedFrameDeclutter_ === !!frameState.declutter &&\n      containsExtent(this.wrappedRenderedExtent_, extent)\n    ) {\n      if (!equals(this.renderedExtent_, renderedExtent)) {\n        this.hitDetectionImageData_ = null;\n        this.renderedExtent_ = renderedExtent;\n      }\n      this.renderedCenter_ = center;\n      this.replayGroupChanged = false;\n      return true;\n    }\n\n    this.replayGroup_ = null;\n\n    const replayGroup = new CanvasBuilderGroup(\n      getRenderTolerance(resolution, pixelRatio),\n      extent,\n      resolution,\n      pixelRatio,\n    );\n\n    const userProjection = getUserProjection();\n    let userTransform;\n    if (userProjection) {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        const extent = loadExtents[i];\n        const userExtent = toUserExtent(extent, projection);\n        vectorSource.loadFeatures(\n          userExtent,\n          toUserResolution(resolution, projection),\n          userProjection,\n        );\n      }\n      userTransform = getTransformFromProjections(userProjection, projection);\n    } else {\n      for (let i = 0, ii = loadExtents.length; i < ii; ++i) {\n        vectorSource.loadFeatures(loadExtents[i], resolution, projection);\n      }\n    }\n\n    const squaredTolerance = getSquaredRenderTolerance(resolution, pixelRatio);\n    let ready = true;\n    const render =\n      /**\n       * @param {import(\"../../Feature.js\").default} feature Feature.\n       * @param {number} index Index.\n       */\n      (feature, index) => {\n        let styles;\n        const styleFunction =\n          feature.getStyleFunction() || vectorLayer.getStyleFunction();\n        if (styleFunction) {\n          styles = styleFunction(feature, resolution);\n        }\n        if (styles) {\n          const dirty = this.renderFeature(\n            feature,\n            squaredTolerance,\n            styles,\n            replayGroup,\n            userTransform,\n            this.getLayer().getDeclutter(),\n            index,\n          );\n          ready = ready && !dirty;\n        }\n      };\n\n    const userExtent = toUserExtent(extent, projection);\n    /** @type {Array<import(\"../../Feature.js\").default>} */\n    const features = vectorSource.getFeaturesInExtent(userExtent);\n    if (vectorLayerRenderOrder) {\n      features.sort(vectorLayerRenderOrder);\n    }\n    for (let i = 0, ii = features.length; i < ii; ++i) {\n      render(features[i], i);\n    }\n    this.renderedFeatures_ = features;\n    this.ready = ready;\n\n    const replayGroupInstructions = replayGroup.finish();\n    const executorGroup = new ExecutorGroup(\n      extent,\n      resolution,\n      pixelRatio,\n      vectorSource.getOverlaps(),\n      replayGroupInstructions,\n      vectorLayer.getRenderBuffer(),\n      !!frameState.declutter,\n    );\n\n    this.renderedResolution_ = resolution;\n    this.renderedRevision_ = vectorLayerRevision;\n    this.renderedRenderOrder_ = vectorLayerRenderOrder;\n    this.renderedFrameDeclutter_ = !!frameState.declutter;\n    this.renderedExtent_ = renderedExtent;\n    this.wrappedRenderedExtent_ = extent;\n    this.renderedCenter_ = center;\n    this.renderedProjection_ = projection;\n    this.renderedPixelRatio_ = pixelRatio;\n    this.replayGroup_ = executorGroup;\n    this.hitDetectionImageData_ = null;\n\n    this.replayGroupChanged = true;\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../Feature.js\").default} feature Feature.\n   * @param {number} squaredTolerance Squared render tolerance.\n   * @param {import(\"../../style/Style.js\").default|Array<import(\"../../style/Style.js\").default>} styles The style or array of styles.\n   * @param {import(\"../../render/canvas/BuilderGroup.js\").default} builderGroup Builder group.\n   * @param {import(\"../../proj.js\").TransformFunction} [transform] Transform from user to view projection.\n   * @param {boolean} [declutter] Enable decluttering.\n   * @param {number} [index] Render order index.\n   * @return {boolean} `true` if an image is loading.\n   */\n  renderFeature(\n    feature,\n    squaredTolerance,\n    styles,\n    builderGroup,\n    transform,\n    declutter,\n    index,\n  ) {\n    if (!styles) {\n      return false;\n    }\n    let loading = false;\n    if (Array.isArray(styles)) {\n      for (let i = 0, ii = styles.length; i < ii; ++i) {\n        loading =\n          renderFeature(\n            builderGroup,\n            feature,\n            styles[i],\n            squaredTolerance,\n            this.boundHandleStyleImageChange_,\n            transform,\n            declutter,\n            index,\n          ) || loading;\n      }\n    } else {\n      loading = renderFeature(\n        builderGroup,\n        feature,\n        styles,\n        squaredTolerance,\n        this.boundHandleStyleImageChange_,\n        transform,\n        declutter,\n        index,\n      );\n    }\n    return loading;\n  }\n}\n\nexport default CanvasVectorLayerRenderer;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}